!function(t,s){"object"==typeof exports&&"object"==typeof module?module.exports=s():"function"==typeof define&&define.amd?define([],s):"object"==typeof exports?exports["p5.mapper"]=s():t["p5.mapper"]=s()}(self,(()=>(()=>{"use strict";var t={};(t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})})(t);var s={dim:function(t){var i;return"object"==typeof t?"object"==typeof(i=t[0])?"object"==typeof i[0]?s._dim(t):[t.length,i.length]:[t.length]:[]},_foreach2:function t(s,i,e,h){if(e===i.length-1)return h(s);var o,r=i[e],n=Array(r);for(o=r-1;o>=0;o--)n[o]=t(s[o],i,e+1,h);return n},cloneV:function(t){var s,i=t.length,e=Array(i);for(s=i-1;-1!==s;--s)e[s]=t[s];return e},clone:function(t){if("object"!=typeof t)return t;var i=s.cloneV,e=s.dim(t);return s._foreach2(t,e,0,i)},diag:function(t){var s,i,e,h,o=t.length,r=Array(o);for(s=o-1;s>=0;s--){for(h=Array(o),i=s+2,e=o-1;e>=i;e-=2)h[e]=0,h[e-1]=0;for(e>s&&(h[e]=0),h[s]=t[s],e=s-1;e>=1;e-=2)h[e]=0,h[e-1]=0;0===e&&(h[0]=0),r[s]=h}return r},rep:function(t,i,e){void 0===e&&(e=0);var h,o=t[e],r=Array(o);if(e===t.length-1){for(h=o-2;h>=0;h-=2)r[h+1]=i,r[h]=i;return-1===h&&(r[0]=i),r}for(h=o-1;h>=0;h--)r[h]=s.rep(t,i,e+1);return r},identity:function(t){return s.diag(s.rep([t],1))},inv:function(t){var i,e,h,o,r,n,l,a,c=s.dim(t),p=Math.abs,u=c[0],f=c[1],d=s.clone(t),y=s.identity(u);for(n=0;n<f;++n){var g=-1,m=-1;for(r=n;r!==u;++r)(l=p(d[r][n]))>m&&(g=r,m=l);for(e=d[g],d[g]=d[n],d[n]=e,o=y[g],y[g]=y[n],y[n]=o,a=e[n],l=n;l!==f;++l)e[l]/=a;for(l=f-1;-1!==l;--l)o[l]/=a;for(r=u-1;-1!==r;--r)if(r!==n){for(i=d[r],h=y[r],a=i[n],l=n+1;l!==f;++l)i[l]-=e[l]*a;for(l=f-1;l>0;--l)h[l]-=o[l]*a,h[--l]-=o[l]*a;0===l&&(h[0]-=o[0]*a)}}return y},dotMMsmall:function(t,s){var i,e,h,o,r,n,l,a,c,p,u;for(o=t.length,r=s.length,n=s[0].length,l=Array(o),i=o-1;i>=0;i--){for(a=Array(n),c=t[i],h=n-1;h>=0;h--){for(p=c[r-1]*s[r-1][h],e=r-2;e>=1;e-=2)u=e-1,p+=c[e]*s[e][h]+c[u]*s[u][h];0===e&&(p+=c[0]*s[0][h]),a[h]=p}l[i]=a}return l},dotMV:function(t,i){var e,h=t.length,o=Array(h),r=s.dotVV;for(e=h-1;e>=0;e--)o[e]=r(t[e],i);return o},dotVV:function(t,s){var i,e,h=t.length,o=t[h-1]*s[h-1];for(i=h-2;i>=1;i-=2)e=i-1,o+=t[i]*s[i]+t[e]*s[e];return 0===i&&(o+=t[0]*s[0]),o},transpose:function(t){var s,i,e,h,o,r=t.length,n=t[0].length,l=Array(n);for(i=0;i<n;i++)l[i]=Array(r);for(s=r-1;s>=1;s-=2){for(h=t[s],e=t[s-1],i=n-1;i>=1;--i)(o=l[i])[s]=h[i],o[s-1]=e[i],(o=l[--i])[s]=h[i],o[s-1]=e[i];0===i&&((o=l[0])[s]=h[0],o[s-1]=e[0])}if(0===s){for(e=t[0],i=n-1;i>=1;--i)l[i][0]=e[i],l[--i][0]=e[i];0===i&&(l[0][0]=e[0])}return l}};const i=s;function e(t,s,e){if(e){var h=s;s=t,t=h}var o,r=[[t[0],t[1],1,0,0,0,-1*s[0]*t[0],-1*s[0]*t[1]],[0,0,0,t[0],t[1],1,-1*s[1]*t[0],-1*s[1]*t[1]],[t[2],t[3],1,0,0,0,-1*s[2]*t[2],-1*s[2]*t[3]],[0,0,0,t[2],t[3],1,-1*s[3]*t[2],-1*s[3]*t[3]],[t[4],t[5],1,0,0,0,-1*s[4]*t[4],-1*s[4]*t[5]],[0,0,0,t[4],t[5],1,-1*s[5]*t[4],-1*s[5]*t[5]],[t[6],t[7],1,0,0,0,-1*s[6]*t[6],-1*s[6]*t[7]],[0,0,0,t[6],t[7],1,-1*s[7]*t[6],-1*s[7]*t[7]]],n=s;try{o=i.inv(i.dotMMsmall(i.transpose(r),r))}catch(t){return console.log(t),[1,0,0,0,1,0,0,0]}for(var l,a=i.dotMMsmall(o,i.transpose(r)),c=i.dotMV(a,n),p=0;p<c.length;p++)c[p]=(l=c[p],Math.round(1e10*l)/1e10);return c[8]=1,c}function h(t,s){return"undefined"!=typeof window&&window===this||void 0===this?new h(t,s):(this.srcPts=t,this.dstPts=s,this.coeffs=e(this.srcPts,this.dstPts,!1),this.coeffsInv=e(this.srcPts,this.dstPts,!0),this)}h.prototype={transform:function(t,s){var i=[];return i[0]=(this.coeffs[0]*t+this.coeffs[1]*s+this.coeffs[2])/(this.coeffs[6]*t+this.coeffs[7]*s+1),i[1]=(this.coeffs[3]*t+this.coeffs[4]*s+this.coeffs[5])/(this.coeffs[6]*t+this.coeffs[7]*s+1),i},transformInverse:function(t,s){var i=[];return i[0]=(this.coeffsInv[0]*t+this.coeffsInv[1]*s+this.coeffsInv[2])/(this.coeffsInv[6]*t+this.coeffsInv[7]*s+1),i[1]=(this.coeffsInv[3]*t+this.coeffsInv[4]*s+this.coeffsInv[5])/(this.coeffsInv[6]*t+this.coeffsInv[7]*s+1),i}};const o=h;function r(t,s){let i=88*(1+t)+80*(s?s[0].charCodeAt(0):2);colorMode(HSB,255);let e=color(i%255,255,255);return colorMode(RGB,255),e}function n(){return drawingContext instanceof WebGLRenderingContext}const l=class{constructor(t,s,i,e=20){this.x=s,this.y=i,this.r=e,this.isControlPoint=!1,this.parent=t,this.xStartDrag=this.x,this.yStartDrag=this.y,this.clickX=0,this.clickY=0,this.col=color(0,255,255)}isMouseOver(){let t=mouseX,s=mouseY;return n()&&(t-=width/2,s-=height/2),dist(t,s,this.x+this.parent.x,this.y+this.parent.y)<this.r}set(t){this.x=t.x,this.y=t.y}startDrag(){this.xStartDrag=this.x,this.yStartDrag=this.y,this.clickX=mouseX,this.clickY=mouseY}moveToMouse(){this.x=mouseX-width/2,this.y=mouseY-height/2}moveTo(){"LINE"===this.parent.type?this.moveToMouse():(this.x=this.xStartDrag+mouseX-this.clickX,this.y=this.yStartDrag+mouseY-this.clickY)}setControlPoint(t){this.isControlPoint=t}interpolateBetween(t,s,i){this.x=t.x+(s.x-t.x)*i,this.y=t.y+(s.y-t.y)*i}display(t=this.col){let s=t;this.isMouseOver()&&isDragging(this)&&(s=color(255)),push(),translate(0,0,5),stroke(s),strokeWeight(2),noFill(),ellipse(this.x,this.y,this.r),fill(s),ellipse(this.x,this.y,this.r/2),pop()}};class a extends l{constructor(t,s,i,e,h){super(t,s,i),this.u=e,this.v=h}set(t){super.set(t),this.u=t.u,this.v=t.v}moveTo(){super.moveTo(),this.parent.calculateMesh()}interpolateTo(t,s){let i=this.x+(t.x-this.x)*s,e=this.y+(t.y-this.y)*s;return new a(this.parent,i,e,0,0)}}const c=a;class p{constructor(t,s,i,e,h,o){p5.Graphics.call(this,s,i,WEBGL,o),this.id=t,this.res=Math.floor(e),this.type=h,this.x=0,this.y=0,this.clickX=0,this.clickY=0,this.xStartDrag=this.x,this.yStartDrag=this.y,this.gridColor=color(200),this.controlPointColor=color(255,0,255)}}p.prototype=Object.create(p5.Graphics.prototype);const u=p,f=class extends u{constructor(t,s,i,e,h,o){super(t,s,i,e,h,o),this.perspT=null,this.initMesh(),this.calculateMesh(),this.controlPointColor=r(this.id,this.type)}render(){}isMouseOver(){}calculateMesh(){}initMesh(){this.mesh=[];for(let t=0;t<this.res;t++)for(let s=0;s<this.res;s++){let i=Math.floor(map(s,0,this.res,0,this.width)),e=Math.floor(map(t,0,this.res,0,this.height)),h=map(s,0,this.res,0,1),o=map(t,0,this.res,0,1);this.mesh[t*this.res+s]=new c(this,i,e,h,o)}this.TL=0,this.TR=this.res-1+0,this.BL=0+(this.res-1)*this.res,this.BR=this.res-1+(this.res-1)*this.res,this.mesh[this.TL].setControlPoint(!0),this.mesh[this.TR].setControlPoint(!0),this.mesh[this.BR].setControlPoint(!0),this.mesh[this.BL].setControlPoint(!0),this.controlPoints=[],this.controlPoints.push(this.mesh[this.TL]),this.controlPoints.push(this.mesh[this.TR]),this.controlPoints.push(this.mesh[this.BR]),this.controlPoints.push(this.mesh[this.BL])}load(t){const{x:s,y:i,points:e}=t;this.x=s,this.y=i;for(const t of e){let s=this.mesh[t.i];s.x=t.x,s.y=t.y,s.u=t.u,s.v=t.v}this.calculateMesh()}getJson(){let t={};t.id=this.id,t.res=this.res,t.x=this.x,t.y=this.y,t.w=this.w,t.h=this.h,t.type=this.type,t.points=[];for(let s=0;s<this.mesh.length;s++)if(this.mesh[s].isControlPoint){let i={};i.i=s,i.x=this.mesh[s].x,i.y=this.mesh[s].y,i.u=this.mesh[s].u,i.v=this.mesh[s].v,t.points.push(i)}return t}isEqual(t){return t.id===this.id&&t.type===this.type}getControlPoints(){return this.controlPoints}select(){let t=this.isMouseOverControlPoints();return t?(t.startDrag(),t):this.isMouseOver()?(this.startDrag(),this):null}startDrag(){this.xStartDrag=this.x,this.yStartDrag=this.y,this.clickX=mouseX,this.clickY=mouseY}moveTo(){this.x=this.xStartDrag+mouseX-this.clickX,this.y=this.yStartDrag+mouseY-this.clickY}isMouseOverControlPoints(){for(const t of this.controlPoints)if(t.isMouseOver())return t;return!1}isPointInTriangle(t,s,i,e,h){let o=createVector(h.x-i.x,h.y-i.y),r=createVector(e.x-i.x,e.y-i.y),n=createVector(t-i.x,s-i.y),l=o.dot(o),a=r.dot(o),c=n.dot(o),p=r.dot(r),u=n.dot(r),f=1/(l*p-a*a),d=(p*c-a*u)*f,y=(l*u-a*c)*f;return d>0&&y>0&&d+y<1}displayControlPoints(){push(),translate(this.x,this.y);for(const t of this.controlPoints)t.display(this.controlPointColor);pop()}displayOutline(){strokeWeight(3),stroke(this.controlPointColor),fill(red(this.controlPointColor),green(this.controlPointColor),blue(this.controlPointColor),50),beginShape();for(const t of this.controlPoints)vertex(t.x,t.y);endShape(CLOSE)}beginDrawing(){this.push()}endDrawing(){this.pop()}getTransformedCursor(t,s){let i=this.perspT(t-this.x,s-this.y);return createVector(i[0],i[1])}getTransformedMouse(){return getTransformedCursor(mouseX,mouseY)}cross2(t,s,i,e){return t*e-s*i}},d=class extends f{constructor(t,s,i,e,h){super(t,s,i,e,"QUAD",h)}isMouseOver(){let t=mouseX-width/2,s=mouseY-height/2;return!(!this.isPointInTriangle(t-this.x,s-this.y,this.mesh[this.TL],this.mesh[this.TR],this.mesh[this.BL])&&!this.isPointInTriangle(t-this.x,s-this.y,this.mesh[this.BL],this.mesh[this.TR],this.mesh[this.BR]))}calculateMesh(){const t=[0,0,this.width,0,this.width,this.height,0,this.height],s=[this.mesh[this.TL].x,this.mesh[this.TL].y,this.mesh[this.TR].x,this.mesh[this.TR].y,this.mesh[this.BR].x,this.mesh[this.BR].y,this.mesh[this.BL].x,this.mesh[this.BL].y];this.perspT=o(t,s);let i=this.width/(this.res-1),e=this.height/(this.res-1);for(let t=0;t<this.mesh.length;t++){if(this.TL==t||this.BR==t||this.TR==t||this.BL==t)continue;let s=t%this.res,h=Math.floor(t/this.res);s*=i,h*=e;let o=this.perspT.transform(s,h);this.mesh[t].x=o[0],this.mesh[t].y=o[1]}}render(t=0,s=0,i=this.width,e=this.height){push(),translate(this.x,this.y),texture(this),beginShape(TRIANGLES);for(let h=0;h<this.res-1;h++)for(let o=0;o<this.res-1;o++)this.getQuadTriangles(h,o,t,s,i,e);endShape(CLOSE),isCalibratingMapper()&&(translate(0,0,3),this.displayOutline(),this.displayGrid()),pop()}displayGrid(){strokeWeight(2),stroke(this.controlPointColor),fill(red(this.controlPointColor),green(this.controlPointColor),blue(this.controlPointColor),50),beginShape(TRIANGLES);for(let t=0;t<this.res-1;t++)for(let s=0;s<this.res-1;s++)this.getQuadTrianglesOutline(t,s);endShape(CLOSE)}getQuadTriangles(t,s,i,e,h,o){let r=this.mesh[t+s*this.res];this.getVertexUV(r,i,e,h,o),r=this.mesh[t+1+s*this.res],this.getVertexUV(r,i,e,h,o),r=this.mesh[t+1+(s+1)*this.res],this.getVertexUV(r,i,e,h,o),this.getVertexUV(r,i,e,h,o),r=this.mesh[t+(s+1)*this.res],this.getVertexUV(r,i,e,h,o),r=this.mesh[t+s*this.res],this.getVertexUV(r,i,e,h,o)}getQuadTrianglesOutline(t,s){let i=this.mesh[t+s*this.res];vertex(i.x,i.y),i=this.mesh[t+1+s*this.res],vertex(i.x,i.y),i=this.mesh[t+1+(s+1)*this.res],vertex(i.x,i.y),vertex(i.x,i.y),i=this.mesh[t+(s+1)*this.res],vertex(i.x,i.y),i=this.mesh[t+s*this.res],vertex(i.x,i.y)}getVertexUV(t,s,i,e,h){let o=map(t.u,0,1,s,s+e),r=map(t.v,0,1,i,i+h);vertex(t.x,t.y,o,r)}},y=class extends f{constructor(t,s,i,e,h){super(t,s,i,e,"TRI",h),this.setTriMesh()}isMouseOver(){let t=mouseX-width/2,s=mouseY-height/2;return!!this.isPointInTriangle(t-this.x,s-this.y,this.mesh[this.TP],this.mesh[this.BL],this.mesh[this.BR])}Barycentric(t,s,i,e,h,o,r){let n=i.sub(s),l=e.sub(s),a=t.sub(s);n.dot(n),n.dot(l),l.dot(l),a.dot(n),a.dot(l)}setTriMesh(){this.TP=Math.floor(this.res/2)-1,this.mesh[this.TP].setControlPoint(!0),this.mesh[this.TL].setControlPoint(!1),this.mesh[this.TR].setControlPoint(!1),this.controlPoints=[],this.controlPoints.push(this.mesh[this.TP],this.mesh[this.BL],this.mesh[this.BR])}render(){push(),translate(this.x,this.y),noStroke(),fill(0),texture(this),beginShape();let t=0,s=this.height;vertex(this.mesh[this.BL].x,this.mesh[this.BL].y,t,s),t=this.width/2,s=0,vertex(this.mesh[this.TP].x,this.mesh[this.TP].y,t,s),t=this.width,s=this.height,vertex(this.mesh[this.BR].x,this.mesh[this.BR].y,t,s),endShape(CLOSE),isCalibratingMapper()&&this.displayOutline(),pop()}},g=new class{constructor(){this.surfaces=[],this.lines=[],this.masks=[],this.dragged=null,this.calibrate=!1,this.pInst=null,this.pMousePressed=!1}createQuadMap(t,s,i=20){const e=new d(this.surfaces.length,t,s,i,this.pInst);return this.surfaces.push(e),e}createTriMap(t,s,i=20){const e=new y(this.surfaces.length,t,s,i,this.pInst);return this.surfaces.push(e),e}createLineMap(t=0,s=0,i=0,e=0){0==t&&0==s&&0==i&&0==e&&(i=200,s=30*this.lines.length,e=30*this.lines.length);const h=new class{constructor(t,s,i,e,h){this.id=h,this.x=0,this.y=0,this.clickX=0,this.clickY=0,this.type="LINE",this.lineW=10,this.lastChecked=0,this.lineC=color(255),this.highlightColor=color(0,255,0),this.controlPointColor=r(this.id,this.type),this.p0=new l(this,t,s,20),this.p1=new l(this,i,e,20),this.controlCol=r(),this.leftToRight(),this.ang=atan2(this.p0.y-this.p1.y,this.p0.x-this.p1.x),this.ang>PI/2&&(this.ang-=2*PI)}load(t){this.p0.x=t.x0,this.p0.y=t.y0,this.p1.x=t.x1,this.p1.y=t.y1}getJson(){let t={};return t.id=this.id,t.x0=this.p0.x,t.y0=this.p0.y,t.x1=this.p1.x,t.y1=this.p1.y,t}display(t=this.lineC){strokeWeight(this.lineW),stroke(t),line(this.p0.x,this.p0.y,this.p1.x,this.p1.y),this.drawEndCaps(this.p0,this.p1,t,t)}displayCenterPulse(t,s=this.lineC){let i=(this.p0.x+this.p1.x)/2,e=(this.p0.y+this.p1.y)/2,h=map(t,0,1,i,this.p0.x),o=map(t,0,1,i,this.p1.x),r=map(t,0,1,e,this.p0.y),n=map(t,0,1,e,this.p1.y);strokeWeight(this.lineW),stroke(s),line(h,r,o,n),this.drawEndCaps({x:h,y:r},{x:o,y:n},s,s)}displayPercent(t,s=this.lineC){let i=t,e=createVector(this.p0.x,this.p0.y),h=createVector(this.p1.x,this.p1.y),o=p5.Vector.lerp(e,h,i);strokeWeight(this.lineW),stroke(s),line(this.p0.x,this.p0.y,o.x,o.y),this.drawEndCaps(e,o,s,s)}displayPercentWidth(t,s=this.lineC){t=constrain(t,0,1);let i=map(t,0,1,0,10);strokeWeight(i),stroke(s),line(this.p0.x,this.p0.y,this.p1.x,this.p1.y),this.drawEndCaps(this.p0,this.p1,s,s,i)}displayNone(){this.display(color(0))}displayRainbowCycle(){colorMode(HSB,255);let t=color(frameCount%255,255,255);this.display(t),colorMode(RGB,255)}displayGradientLine(t,s,i,e=1,h=!1){i+=e,i%=1;let o=1/height;for(let e=0;e<1;e+=o){let h=(e/2+i)%1,r=this.get2CycleColor(t,s,h);this.displaySegment(e,o,r)}}displayCalibration(){let t=color(0,255,0);this.display(t)}displayControlPoints(){this.p0.display(this.controlPointColor),this.p1.display(this.controlPointColor)}drawEndCaps(t,s,i=this.lineC,e=this.lineC,h=this.lineW){noStroke(),dist(t.x,t.y,s.x,s.y)>1&&(fill(i),ellipse(t.x,t.y,h,h),fill(e),ellipse(s.x,s.y,h,h))}displaySegment(t,s,i=this.lineC){strokeWeight(this.lineW),stroke(i);let e=createVector(this.p0.x,this.p0.y),h=createVector(this.p1.x,this.p1.y),o=p5.Vector.lerp(e,h,t),r=p5.Vector.lerp(o,h,t+s);line(o.x,o.y,r.x,r.y),this.drawEndCaps(o,r,i,i)}get2CycleColor(t,s,i){return i=constrain(i,0,1),(i*=2)<1?lerpColor(t,s,i):(i=map(i,1,2,0,1),lerpColor(s,t,i))}get3CycleColor(t,s,i){return i=constrain(i,0,1),(i*=3)<1?lerpColor(t,s,i):i<2?(i=map(i,1,2,1,0),lerpColor(c3,s,i)):(i=map(i,2,3,1,0),lerpColor(t,c3,i))}getPointHighlight(t){colorMode(RGB,255),this.isMouseOverPoint(t)?stroke(0,255,0):stroke(255,0,0)}isMouseOverPoint(t){return dist(t.x,t.y,mouseX-width/2,mouseY-height/2)<t.r}isMouseOver(){let t=this.p0.x,s=this.p0.y,i=this.p1.x,e=this.p1.y,h=mouseX-width/2,o=mouseY-height/2,r=dist(h,o,t,s),n=dist(h,o,i,e),l=dist(t,s,i,e);return r+n>=l-.2&&r+n<=l+.2}select(){let t=mouseX-width/2,s=mouseY-height/2;return dist(this.p0.x,this.p0.y,t,s)<this.p0.r?this.p0:dist(this.p1.x,this.p1.y,t,s)<this.p1.r?this.p1:null}leftToRight(){if(this.p0.x>this.p1.x){let t=createVector(this.p0.x,this.p0.y);this.p0.set(this.p1),this.p1.set(t)}}rightToLeft(){if(this.p0.x<this.p1.x){let t=createVector(this.p0.x,this.p0.y);this.p0.set(this.p1),this.p1.set(t)}}}(t,s,i,e,this.lines.length);return this.lines.push(h),h}createMaskMap(t=3){t<3&&(t=3);let s=new class{constructor(t,s){this.id=t,this.x=0,this.y=0,this.clickX=0,this.clickY=0,this.xStartDrag=this.x,this.yStartDrag=this.y,this.type="MASK",this.controlPointColor=r(this.id,this.type),this.points=[];for(let t=0;t<s;t++){let i=200,e=i*cos(t/s*2*PI),h=i*sin(t/s*2*PI);n()||(e+=width/2,h+=height/2);let o=new l(this,e,h);o.isControlPoint=!0,this.points.push(o)}}setPoints(t){this.points=[];for(const s of t){let t=new l(this,s.x,s.y);t.isControlPoint=!0,this.points.push(t)}}display(t=color(0)){push(),translate(this.x,this.y,1),noStroke(),isCalibratingMapper()?fill(this.controlPointColor):(fill(t),stroke(t)),beginShape();for(const t of this.points)vertex(t.x,t.y);endShape(),pop()}displayControlPoints(){push(),translate(this.x,this.y,2);for(const t of this.points)t.display(this.controlPointColor);pop()}isMouseOver(){let t={x:mouseX,y:mouseY};return n()&&(t.x-=width/2,t.y-=height/2),function(t,s,i){for(var e=t.x,h=t.y,o=!1,r=0,n=s.length-1;r<s.length;n=r++){var l=s[r].x+i.x,a=s[r].y+i.y,c=s[n].x+i.x,p=s[n].y+i.y;a>h!=p>h&&e<(c-l)*(h-a)/(p-a)+l&&(o=!o)}return o}(t,this.points,{x:this.x,y:this.y})}load(t){const{x:s,y:i,points:e}=t;this.x=s,this.y=i;for(const t of e){let s=this.points[t.i];s.x=t.x,s.y=t.y}}getJson(){let t={};t.id=this.id,t.x=this.x,t.y=this.y,t.type=this.type,t.points=[];for(let s=0;s<this.points.length;s++){let i={};i.i=s,i.x=this.points[s].x,i.y=this.points[s].y,t.points.push(i)}return t}isEqual(t){return t.type===this.type&&t.id===this.id}select(){for(const t of this.points)if(t.isMouseOver())return t.startDrag(),t;return this.isMouseOver()?(this.startDrag(),this):null}startDrag(){this.xStartDrag=this.x,this.yStartDrag=this.y,this.clickX=mouseX,this.clickY=mouseY}moveTo(){this.x=this.xStartDrag+mouseX-this.clickX,this.y=this.yStartDrag+mouseY-this.clickY}}(this.masks.length,t);return this.masks.push(s),s}onClick(){if(!this.calibrate)return;let t=null;for(const s of this.masks)if(this.dragged=s.select(),null!=this.dragged)return void(t=s);for(let s=this.lines.length-1;s>=0;s--){let i=this.lines[s];if(this.dragged=i.select(),null!=this.dragged)return void(t=i)}for(let s=this.surfaces.length-1;s>=0;s--){let i=this.surfaces[s];if(this.dragged=i.select(),null!=this.dragged)return void(t=i)}}onDrag(){null!=this.dragged&&this.dragged.moveTo()}onRelease(){this.dragged=null}isDragging(t){return null===this.dragged||this.dragged===t}updateEvents(){mouseIsPressed?this.pMousePressed?this.onDrag():this.onClick():this.pMousePressed&&this.onRelease(),this.pMousePressed=mouseIsPressed}load(t="maps/map.json"){console.log(`loading json file: ${t}`),loadJSON(`${t}`,this.loadedJson.bind(this),(s=>console.log(`error loading ${t}`,s)))}loadedJson(t){t.masks&&this.loadMasks(t),t.surfaces&&this.loadSurfaces(t),t.lines&&this.loadLines(t)}loadMasks(t){let s=t.masks;s.length!==this.masks.length&&console.warn(`json calibration file has ${s.length} masks but there are ${this.masks.length} masks in memory (check sketch.js for # of mask objects)`);let i=0;for(;i<s.length&&i<this.masks.length;){const t=this.masks[i];t.isEqual(this.masks[i])?t.load(s[i]):console.warn("mismatch between calibration mask types / ids"),i++}}loadSurfaces(t){let s=t.surfaces;s.length!==this.surfaces.length&&console.warn(`json calibration file has ${s.length} surface maps but there are ${this.surfaces.length} surface maps in memory (check sketch.js for # of map objects)`);const i=s.filter((t=>"TRI"===t.type)),e=s.filter((t=>"QUAD"===t.type)),h=this.surfaces.filter((t=>"TRI"===t.type)),o=this.surfaces.filter((t=>"QUAD"===t.type));let r=0;for(;r<i.length&&r<h.length;){const t=h[r];t.isEqual(h[r])?t.load(i[r]):console.warn("mismatch between calibration surface types / ids"),r++}for(r=0;r<e.length&&r<o.length;){const t=o[r];t.isEqual(o[r])?t.load(e[r]):console.warn("mismatch between calibration surface types / ids"),r++}}loadLines(t){let s=t.lines;s.length!==this.lines.length&&console.warn(`json calibration file has ${s.length} line maps but there are ${this.lines.length} line maps in memory`);let i=0;for(;i<s.length&&i<this.lines.length;)this.lines[i].load(s[i]),i++}save(t="map.json"){console.log("saving all mapped surfaces to json...");let s={surfaces:[],lines:[],masks:[]};for(const t of this.masks)s.masks.push(t.getJson());for(const t of this.surfaces)s.surfaces.push(t.getJson());for(const t of this.lines)s.lines.push(t.getJson());saveJSON(s,`${t}`)}export(){let t={surfaces:[],lines:[],masks:[]};for(const s of this.masks)t.masks.push(s.getJson());for(const s of this.surfaces)t.surfaces.push(s.getJson());for(const s of this.lines)t.lines.push(s.getJson());return t}startCalibration(){this.calibrate=!0}stopCalibration(){this.calibrate=!1}toggleCalibration(){this.calibrate=!this.calibrate}beginSurfaces(){for(const t of this.surfaces)t.beginDrawing()}endSurfaces(){for(const t of this.surfaces)t.endDrawing()}renderSurfaces(){this.endSurfaces();for(const t of this.surfaces)t.render()}display(){this.renderSurfaces(),this.displayControlPoints()}displayControlPoints(){if(this.calibrate){for(const t of this.masks)t.displayControlPoints();for(const t of this.surfaces)t.displayControlPoints();for(const t of this.lines)t.displayCalibration(),t.displayControlPoints()}}getOscillator(t,s=0){return function(t=1,s=0){return t=constrain(t,.01,100),.5+.5*sin(frameCount/(60*t)*2*PI+s)}(t,s)}};return p5.prototype.createProjectionMapper=function(t){return g.pInst=this,g},p5.prototype.isCalibratingMapper=function(){return g.calibrate},p5.prototype.isDragging=function(t){return g.isDragging(t)},p5.prototype.registerMethod("pre",(()=>g.beginSurfaces())),p5.prototype.registerMethod("post",(()=>g.display())),p5.prototype.registerMethod("post",(()=>g.updateEvents())),t})()));